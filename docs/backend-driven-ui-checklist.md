# Backend-driven UI (KMP): чек-лист и подход

Документ поможет поднять backend-driven UI в мультиплатформенном приложении (Android/iOS) с максимальным количеством кода на Kotlin и минимальным — на Swift.

## Цели
- Единый источник правды о UI на бэкенде (BFF/опытный слой).
- Переиспользуемый UI-рендерер и бизнес-логика в `shared` (KMP).
- Минимальный Swift: только хостинг Kotlin/Compose-экрана и системные интеграции.

## Архитектура и договорённости
- `BFF` поверх core-сервисов; стабилизированный контракт (версионирование + capability negotiation).
- Формат описания UI: JSON/Protobuf со схемой (json schema/typed DSL). Фиксация версий схемы в репо.
- Фича-флаги/эксперименты в BFF; конфигурация окружений (dev/stage/prod) — один переключатель на клиенте.
- Политика кэширования, TTL и max-payload прописаны в контракте.
- Встроенная обратная совместимость: обязательные/опциональные поля, default-значения на клиенте.

## Контракт API (минимальный набор)
- `screen_id`, `version`, `layout` (дерево компонентов), `data` (контент), `actions` (события), `validation`, `theme`.
- Правила навигации: явные deeplink-и/route-и, правила переходов, prefetch зависимостей.
- Ошибки: машинно-парсимые коды + человекочитаемое сообщение; фоллбек-стратегии на клиенте.
- Доступность: семантика компонентов, labels/hints передаются в контракте.
- Аналитика: событие/параметры, когда и чем триггерится.

## Клиентский стек (shared, Kotlin)
- Сетевой слой Ktor (JSON + logging + retries с backoff).
- Десериализация: kotlinx.serialization с жёсткой схемой; runtime-валидатор (schema/hand-written checks).
- Маппинг DTO → доменная модель → UI-модель; дефолты для опциональных полей.
- Кэш: in-memory + диск (SQLDelight/KeyValue); конфиг через контракт (ttl/etag).
- State management: MVI/Reducer в `shared`; side effects для сетевых вызовов/аналитики.
- DI: Koin/Hilt-like для `shared`; модули для платформенных зависимостей.
- Логи/метрики: единый интерфейс в `shared` + платформенные адаптеры (Logcat/OSLog).
- Ошибки: типизированные sealed-классы; graceful degradation (skeleton/placeholder/last-known-good).

## UI-рендерер (Compose Multiplatform)
- Базовый движок: Compose Multiplatform в `shared`; набор компонентов, собираемых из контракта.
- Темизация: светлая/тёмная палитры, масштабы шрифтов; override из контракта с белым списком.
- Динамический UI: фабрика компонентов (Text/Image/Button/List/Form), layout primitives (Row/Column/Box/Lazy*).
- Валидаторы: синхронные (на ввод) + отложенные (по submit); подсветка ошибок из контракта.
- Доступность: contentDescription/role передаются из JSON; поддержка фокуса/подсказок.

## Минимальный Swift-слой (iOS)
- Сборка: `shared` как `.framework` через Kotlin/Native; Compose Multiplatform для iOS (Skia).
- Swift-код только для:
  - хостинга ComposeView/UIViewController, который вызывает `SharedAppRoot(screenId, params)`;
  - интеграции системных сервисов (push, deeplink, keychain/secure storage) через ожидаемые/реализованные интерфейсы;
  - передачи lifecycle-событий и windowInsets.
- Навигация: вызывается из Kotlin (callback в Swift только для системных экранов, если нужны).
- Ошибки рендерера/нетворка логируются через общий логгер (Swift мостит в Kotlin).

## Навигация и события
- Глобальный роутер в `shared`; сервер отдаёт `route`/`deeplink`/`present_modally`.
- Таблицы соответствия `action_id → handler` с безопасными параметрами.
- Прогрев/прелоад: parallel fetch для вложенных экранов; cancelation при уходе со страницы.
- Offline-first: читать локальный кеш, фоновой догон после сети; конфликт-резолюция для форм.

## Безопасность и надёжность
- Подпись конфигураций/моделей (хотя бы HMAC) для чувствительных экранов.
- Rate limit на клиенте для action-эндпоинтов; защита от replay для форм.
- Ограничение глубины layout/children, guardrails на размеры списков/картинок.
- Circuit breaker на сетевых вызовах; backpressure на рендерер больших списков.

## Тестирование
- Контрактные тесты BFF (json schema + golden samples).
- Интеграционные UI-тесты: автоген из контрактов (happy/error/partial payload).
- Снимочные тесты для компонентов/темы (Compose screenshot tests).
- Нагрузочные: большие формы/списки; деградация сети/таймауты/частичные payloads.
- Регресс iOS-хоста: smoke-тест на запуск Compose-экрана + навигация/инпут.

## Поставка и откаты
- Версионирование схем: `schema_vX` в репо + миграции в клиенте.
- Feature flags/kill-switch для проблемных экранов; fallback на локальный шаблон.
- Канареечный rollout по проценту пользователей/платформе; мониторинг ошибок/перформанса.

## Минимальный порядок работ (roadmap)
1) Зафиксировать формат контракта (json schema + примеры) и политику версий.
2) Поднять BFF-эндпоинты с стабами экранов + фича-флаги.
3) Реализовать в `shared` сетевой слой + десериализацию + кеш.
4) Сделать базовый рендерер Compose (текст/кнопка/картинка/список/формы) + валидаторы.
5) Навигация и action-обработчики в `shared`; аналитика и логирование.
6) Собрать iOS-хост (минимальный Swift) + интегрировать lifecycle/deeplink.
7) Покрыть контрактными и UI-снимочными тестами; прогнать деградацию сети.
8) Включить мониторинг, канарейку и kill-switch; подготовить инструкцию по откату.

## Что учесть в поддержке
- Инструмент для инспекции payload (dev меню) + ручная подмена ответа.
- Версионный реестр экранов/акций, чтобы не ломать старые клиенты.
- SLA на доставку статики (иконки/изображения) и fallbacks при 404/slow CDN.
- Документация для дизайна: разрешённые компоненты, лимиты на размер/иерархию.
